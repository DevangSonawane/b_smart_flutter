import 'dart:io';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:crypto/crypto.dart';
import 'dart:convert';
import '../supabase_service.dart';
import '../../models/auth/device_session_model.dart';

class DeviceService {
  static final DeviceService _instance = DeviceService._internal();
  factory DeviceService() => _instance;

  DeviceService._internal();

  DeviceInfo? _cachedDeviceInfo;
  final DeviceInfoPlugin _deviceInfoPlugin = DeviceInfoPlugin();

  // Get device information
  Future<DeviceInfo> getDeviceInfo() async {
    if (_cachedDeviceInfo != null) {
      return _cachedDeviceInfo!;
    }

    try {
      String deviceId;
      String deviceName;
      String deviceType;
      String? deviceFingerprint;

      if (Platform.isAndroid) {
        final androidInfo = await _deviceInfoPlugin.androidInfo;
        deviceId = androidInfo.id;
        deviceName = '${androidInfo.brand} ${androidInfo.model}';
        deviceType = 'Android';
        deviceFingerprint = _generateFingerprint({
          'id': androidInfo.id,
          'brand': androidInfo.brand,
          'model': androidInfo.model,
          'manufacturer': androidInfo.manufacturer,
          'version': androidInfo.version.release,
        });
      } else if (Platform.isIOS) {
        final iosInfo = await _deviceInfoPlugin.iosInfo;
        deviceId = iosInfo.identifierForVendor ?? 'unknown';
        deviceName = '${iosInfo.name} (${iosInfo.model})';
        deviceType = 'iOS';
        deviceFingerprint = _generateFingerprint({
          'id': iosInfo.identifierForVendor ?? 'unknown',
          'name': iosInfo.name,
          'model': iosInfo.model,
          'systemName': iosInfo.systemName,
          'systemVersion': iosInfo.systemVersion,
        });
      } else {
        // Fallback for other platforms
        deviceId = 'unknown';
        deviceName = 'Unknown Device';
        deviceType = Platform.operatingSystem;
        deviceFingerprint = _generateFingerprint({
          'os': Platform.operatingSystem,
          'version': Platform.operatingSystemVersion,
        });
      }

      final packageInfo = await PackageInfo.fromPlatform();
      final userAgent =
          '${packageInfo.appName}/${packageInfo.version} ($deviceType)';

      _cachedDeviceInfo = DeviceInfo(
        deviceId: deviceId,
        deviceName: deviceName,
        deviceType: deviceType,
        deviceFingerprint: deviceFingerprint,
        ipAddress: null, // Will be set by backend if needed
        userAgent: userAgent,
      );

      return _cachedDeviceInfo!;
    } catch (e) {
      // Fallback if device info fails
      return DeviceInfo(
        deviceId: 'unknown',
        deviceName: 'Unknown Device',
        deviceType: Platform.operatingSystem,
        deviceFingerprint: null,
        ipAddress: null,
        userAgent: 'b_smart/1.0.0',
      );
    }
  }

  // Generate device fingerprint hash
  String _generateFingerprint(Map<String, dynamic> data) {
    final jsonString = jsonEncode(data);
    final bytes = utf8.encode(jsonString);
    final digest = sha256.convert(bytes);
    return digest.toString();
  }

  // Get or create device session
  Future<DeviceSession?> getOrCreateDeviceSession(String userId) async {
    final deviceInfo = await getDeviceInfo();
    final supabase = SupabaseService();

    // Check if device session exists
    final existing = await supabase.getDeviceSession(deviceInfo.deviceId);

    if (existing != null) {
      // Update last active time
      await supabase.upsertDeviceSession({
        'user_id': userId,
        'device_id': deviceInfo.deviceId,
        'device_name': deviceInfo.deviceName,
        'device_type': deviceInfo.deviceType,
        'last_active_at': DateTime.now().toIso8601String(),
      });

      return DeviceSession.fromJson(existing);
    }

    // Create new device session
    final sessionData = {
      'user_id': userId,
      'device_id': deviceInfo.deviceId,
      'device_name': deviceInfo.deviceName,
      'device_type': deviceInfo.deviceType,
      'last_active_at': DateTime.now().toIso8601String(),
      'is_trusted': false,
    };

    await supabase.upsertDeviceSession(sessionData);

    return DeviceSession.fromJson({
      'id': '', // Will be generated by database
      ...sessionData,
      'created_at': DateTime.now().toIso8601String(),
    });
  }

  // Mark device as trusted
  Future<void> markDeviceAsTrusted(String deviceId) async {
    final supabase = SupabaseService();
    await supabase.client
        .from('device_sessions')
        .update({'is_trusted': true})
        .eq('device_id', deviceId);
  }

  // Check if device is trusted
  Future<bool> isDeviceTrusted(String deviceId) async {
    final session = await SupabaseService().getDeviceSession(deviceId);
    return session?['is_trusted'] as bool? ?? false;
  }

  // Detect suspicious login (different device, IP, etc.)
  Future<bool> isSuspiciousLogin(String userId, String deviceId) async {
    final supabase = SupabaseService();

    // Check if this is a known device
    final deviceSession = await supabase.getDeviceSession(deviceId);
    if (deviceSession != null) {
      final isTrusted = deviceSession['is_trusted'] as bool? ?? false;
      if (isTrusted) {
        return false; // Trusted device, not suspicious
      }
    }

    // Check if user has other active sessions
    final activeSessions = await supabase.client
        .from('device_sessions')
        .select()
        .eq('user_id', userId)
        .eq('is_trusted', true);

    // If user has trusted devices and this is a new device, it's suspicious
    if (activeSessions.isNotEmpty && deviceSession == null) {
      return true;
    }

    return false;
  }
}
